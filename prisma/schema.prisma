// Prisma Schema for Token-Burn Chatbot Testing Platform

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ConnectorType enum
enum ConnectorType {
  HTTP_REST
  WEBSOCKET
  GRPC
  SSE
}

// AuthType enum
enum AuthType {
  NONE
  BEARER_TOKEN
  API_KEY
  BASIC_AUTH
  CUSTOM_HEADER
  OAUTH2
}

// SessionStatus enum
enum SessionStatus {
  PENDING
  QUEUED
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

// Target: Represents a chatbot endpoint to test
model Target {
  id          String   @id @default(cuid())
  name        String
  description String?

  // Connector configuration
  connectorType  ConnectorType
  endpoint       String           // URL, WebSocket URI, gRPC address

  // Authentication
  authType       AuthType
  authConfig     Json             // Encrypted credentials, API keys, headers

  // Request/Response templating
  requestTemplate   Json          // JSON template for wrapping messages
  responseTemplate  Json          // JSON path to extract response

  // Protocol-specific config
  protocolConfig Json?            // Headers, timeouts, retry config

  // Status
  isActive    Boolean  @default(true)

  // Relations
  sessions    Session[]
  scenarios   Scenario[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([connectorType])
  @@index([isActive])
}

/// Scenario - Test scenario definition
model Scenario {
  id          String  @id @default(cuid())
  name        String
  description String?
  category    String  @default("custom")

  // Target relationship (optional - scenarios can be reused)
  targetId String?
  target   Target? @relation(fields: [targetId], references: [id], onDelete: SetNull)

  // Flow configuration
  flowConfig Json // Array of flow steps

  // Execution parameters
  repetitions    Int  @default(1)
  concurrency    Int  @default(1)
  delayBetweenMs Int  @default(0)
  messageTemplates Json
  verbosityLevel String @default("normal")

  // Status
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  sessions Session[]
  scheduledJobs ScheduledJob[]

  @@index([category])
  @@index([isActive])
  @@index([targetId])
}

// Session: A single test execution
model Session {
  id            String        @id @default(cuid())

  // References
  target        Target        @relation(fields: [targetId], references: [id])
  targetId      String

  scenario      Scenario?     @relation(fields: [scenarioId], references: [id])
  scenarioId    String?

  // Execution details
  status        SessionStatus @default(PENDING)
  startedAt     DateTime?
  completedAt   DateTime?

  // Configuration snapshot (immutable)
  executionConfig Json         // Frozen scenario + target config

  // File-based logging
  logPath       String?        // Path to logs/sessions/{id}/

  // Summary metrics (cached from log analysis)
  summaryMetrics Json?

  // Metrics relation
  metrics       SessionMetric[]

  // Comparison relations
  comparisonsA  Comparison[] @relation("ComparisonSessionA")
  comparisonsB  Comparison[] @relation("ComparisonSessionB")

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([targetId])
  @@index([scenarioId])
  @@index([status])
  @@index([startedAt])
}

// SessionMetric: Granular per-message metrics
model SessionMetric {
  id            String   @id @default(cuid())

  session       Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId     String

  // Message metadata
  messageIndex  Int
  promptTokens  Int?
  completionTokens Int?
  totalTokens   Int?

  // Timing
  requestSentAt   DateTime
  responseReceivedAt DateTime
  responseTimeMs  Float

  // Status
  success       Boolean
  errorType     String?
  errorMessage  String?

  // Repetition detection
  repetitionScore Float?  // 0-1: how similar to previous responses

  createdAt     DateTime @default(now())

  @@index([sessionId])
  @@index([messageIndex])
}

// ScheduledJob: Cron-like scheduling for scenarios
model ScheduledJob {
  id          String   @id @default(cuid())
  name        String

  scenario    Scenario @relation(fields: [scenarioId], references: [id])
  scenarioId  String

  cronExpression String  // e.g., "0 */6 * * *"
  timezone    String   @default("UTC")

  isEnabled   Boolean  @default(true)
  lastRunAt   DateTime?
  nextRunAt   DateTime?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([isEnabled])
  @@index([nextRunAt])
}

// Comparison: A/B test comparison between two sessions
model Comparison {
  id          String   @id @default(cuid())
  name        String
  description String?

  // The two sessions being compared
  sessionAId  String
  sessionA    Session  @relation("ComparisonSessionA", fields: [sessionAId], references: [id])
  sessionBId  String
  sessionB    Session  @relation("ComparisonSessionB", fields: [sessionBId], references: [id])

  // Comparison results (computed)
  results     Json?    // { avgResponseTimeDiff, tokenUsageDiff, errorRateDiff, ... }
  status      String   @default("pending")  // pending, computing, completed, failed

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([sessionAId])
  @@index([sessionBId])
  @@index([status])
}

// DeliveryStatus enum for webhook deliveries
enum DeliveryStatus {
  PENDING
  DELIVERED
  FAILED
  RETRYING
}

// Webhook: Registered webhook endpoint for event notifications
model Webhook {
  id          String   @id @default(cuid())
  name        String
  url         String   // Delivery endpoint URL
  events      String[] // e.g. ["session.completed", "session.failed"]
  secret      String   // HMAC-SHA256 signing key (encrypted at rest)
  isActive    Boolean  @default(true)

  // Retry configuration
  retryConfig Json     @default("{\"maxRetries\": 5, \"backoffMs\": 1000, \"backoffMultiplier\": 2}")

  // Relations
  deliveries  WebhookDelivery[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([isActive])
}

// WebhookDelivery: Individual delivery attempt record
model WebhookDelivery {
  id            String         @id @default(cuid())

  webhook       Webhook        @relation(fields: [webhookId], references: [id], onDelete: Cascade)
  webhookId     String

  event         String         // e.g. "session.completed"
  payload       Json           // The delivered payload

  status        DeliveryStatus @default(PENDING)
  statusCode    Int?           // HTTP response code from receiver
  attempts      Int            @default(0)
  lastAttemptAt DateTime?
  nextRetryAt   DateTime?
  error         String?        // Last error message

  createdAt     DateTime       @default(now())

  @@index([webhookId])
  @@index([status])
  @@index([createdAt])
}
