# GitLab CI/CD Pipeline for Token-Burn
# Automated testing, building, and deployment

image: node:20-alpine

# Cache node modules for faster builds
cache:
  key:
    files:
      - pnpm-lock.yaml
  paths:
    - .pnpm-store
    - node_modules

# Define pipeline stages
stages:
  - lint
  - test
  - build
  - deploy

# Install dependencies before any job
before_script:
  - npm install -g pnpm
  - pnpm config set store-dir .pnpm-store
  - pnpm install --frozen-lockfile

# Lint stage - Check code quality
lint:typescript:
  stage: lint
  script:
    - pnpm run lint
  only:
    - merge_requests
    - main

# Test stage - Run unit and integration tests
test:unit:
  stage: test
  services:
    - postgres:16-alpine
    - redis:7-alpine
  variables:
    POSTGRES_DB: token_burn_test
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    DATABASE_URL: postgresql://postgres:postgres@postgres:5432/token_burn_test
    REDIS_URL: redis://redis:6379
  script:
    - pnpm run test
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
  only:
    - merge_requests
    - main

# Build stage - Build Docker images
build:app:
  stage: build
  image: docker:24-alpine
  services:
    - docker:24-dind
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA -t $CI_REGISTRY_IMAGE:latest -f docker/Dockerfile .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
  only:
    - main

build:worker:
  stage: build
  image: docker:24-alpine
  services:
    - docker:24-dind
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $CI_REGISTRY_IMAGE/worker:$CI_COMMIT_SHA -t $CI_REGISTRY_IMAGE/worker:latest -f docker/Dockerfile.worker .
    - docker push $CI_REGISTRY_IMAGE/worker:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE/worker:latest
  only:
    - main

# Deploy to staging - Automatic
deploy:staging:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$STAGING_SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $STAGING_HOST >> ~/.ssh/known_hosts
  script:
    - ssh $STAGING_USER@$STAGING_HOST "cd /opt/token-burn && docker compose -f infra/docker-compose.prod.yml pull && docker compose -f infra/docker-compose.prod.yml up -d"
  environment:
    name: staging
    url: https://staging.token-burn.example.com
  only:
    - main

# Deploy to production - Manual approval required
deploy:production:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$PRODUCTION_SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $PRODUCTION_HOST >> ~/.ssh/known_hosts
  script:
    - ssh $PRODUCTION_USER@$PRODUCTION_HOST "cd /opt/token-burn && docker compose -f infra/docker-compose.prod.yml pull && docker compose -f infra/docker-compose.prod.yml up -d"
  environment:
    name: production
    url: https://token-burn.example.com
  when: manual
  only:
    - main
